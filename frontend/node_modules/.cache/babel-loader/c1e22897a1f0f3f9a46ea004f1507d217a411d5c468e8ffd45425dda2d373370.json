{"ast":null,"code":"// Константы - расширенный временной диапазон для покрытия операций через полночь\nexport const DAY_START = -6 * 60; // начинаем ось с 18:00 предыдущего дня (-6 часов)\nexport const DAY_END = 30 * 60; // до 06:00 следующего дня (+30 часов от полуночи)\nexport const GRID_STEP = 30; // шаг сетки 30 мин (было 60) для более детального отображения\nexport const FLEX_HOURS = 9; // длительность flex-смены (ч)\n\nexport const RULE = {\n  // derivation из STD\n  LOAD_SMS: 180,\n  // начало загрузки автолифта до STD (SMS)\n  LOAD_DMS: 240,\n  // для DMS\n  WINDOW_TO_SERVICE: 15,\n  // от окна до начала обслуживания\n  SERVICE_SMS: 19,\n  // длительность обслуживания SMS\n  SERVICE_DMS: 45,\n  // длительность обслуживания DMS\n  LEAVE_BEFORE_STD: 60,\n  // отъезд от ВС до STD\n  RETURN_UNLOAD: 20,\n  // возврат в окно после обслуживания (20 мин)\n  TRAVEL: 20,\n  // переезд между бортами\n\n  // визуал «скобки»\n  BRACKET_PAD_LEFT: 120,\n  // −2:00 от первого бара в цепочке\n  BRACKET_PAD_RIGHT: 0,\n  // без дополнительного хвоста — скобка заканчивается по разгрузке\n\n  // подсказка-буфер при dnd\n  RED_ZONE: 15 // 15 минут\n};\n\n// Утилиты\nexport const uid = () => Math.random().toString(36).slice(2, 9);\nexport const clamp = (v, a, b) => Math.max(a, Math.min(b, v));\nexport const clampDay = m => clamp(m, DAY_START, DAY_END);\n\n// Функция для определения дня относительно базового дня (0 = текущий день)\nexport const getDayOffset = m => {\n  if (m < 0) return -1; // Предыдущий день\n  if (m >= 24 * 60) return 1; // Следующий день\n  return 0; // Текущий день\n};\nexport function toHHMM(m) {\n  // Нормализуем время с учетом расширенного диапазона\n  const totalMinutes = Math.round(m);\n  const hours = Math.floor(totalMinutes / 60);\n  const minutes = (totalMinutes % 60 + 60) % 60;\n\n  // Определяем дату относительно текущего дня\n  if (hours < 0) {\n    // Предыдущий день\n    const actualHours = (hours % 24 + 24) % 24;\n    return `${actualHours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\n  } else if (hours >= 24) {\n    // Следующий день\n    const actualHours = hours % 24;\n    return `${actualHours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\n  } else {\n    // Текущий день\n    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\n  }\n}\n\n// Функция для компактного отображения времени с учетом дат\nexport function toCompactTime(start, end, width) {\n  const startDay = getDayOffset(start);\n  const endDay = getDayOffset(end);\n  if (width >= 90) {\n    // Полное время с пробелами для широких баров\n    return `${toHHMM(start)} - ${toHHMM(end)}`;\n  } else if (width >= 65) {\n    // Без пробелов для средних баров\n    return `${toHHMM(start)}-${toHHMM(end)}`;\n  } else if (width >= 50) {\n    // Сокращенное время без ведущих нулей\n    let shortStart = toHHMM(start).replace(/^0/, '');\n    let shortEnd = toHHMM(end).replace(/^0/, '');\n    return `${shortStart}-${shortEnd}`;\n  } else {\n    // Только время начала для очень узких баров\n    return toHHMM(start).replace(/^0/, '');\n  }\n}\nexport function toMin(hhmm) {\n  const match = hhmm.match(/(\\d{1,2}):(\\d{2})/);\n  if (!match) return NaN;\n  return +match[1] * 60 + +match[2];\n}\nexport const DMS_TYPES = new Set(['77W', '77R', '773', '744', '333', '359']);\nexport const SMS_TYPES = new Set(['320', '321', '32A', '32B', '32N', '32Q', '73H', '739', 'SU9']);\nexport const isDMS = t => DMS_TYPES.has(t.toUpperCase());\nexport const isSMS = t => SMS_TYPES.has(t.toUpperCase());\nexport const normType = t => t.toUpperCase().trim();","map":{"version":3,"names":["DAY_START","DAY_END","GRID_STEP","FLEX_HOURS","RULE","LOAD_SMS","LOAD_DMS","WINDOW_TO_SERVICE","SERVICE_SMS","SERVICE_DMS","LEAVE_BEFORE_STD","RETURN_UNLOAD","TRAVEL","BRACKET_PAD_LEFT","BRACKET_PAD_RIGHT","RED_ZONE","uid","Math","random","toString","slice","clamp","v","a","b","max","min","clampDay","m","getDayOffset","toHHMM","totalMinutes","round","hours","floor","minutes","actualHours","padStart","toCompactTime","start","end","width","startDay","endDay","shortStart","replace","shortEnd","toMin","hhmm","match","NaN","DMS_TYPES","Set","SMS_TYPES","isDMS","t","has","toUpperCase","isSMS","normType","trim"],"sources":["/Users/igordvoretskii/Documents/aeromar-python/frontend/src/utils.ts"],"sourcesContent":["// Константы - расширенный временной диапазон для покрытия операций через полночь\nexport const DAY_START = -6 * 60;       // начинаем ось с 18:00 предыдущего дня (-6 часов)\nexport const DAY_END = 30 * 60;         // до 06:00 следующего дня (+30 часов от полуночи)\nexport const GRID_STEP = 30;            // шаг сетки 30 мин (было 60) для более детального отображения\nexport const FLEX_HOURS = 9;           // длительность flex-смены (ч)\n\nexport const RULE = {\n  // derivation из STD\n  LOAD_SMS: 180,                // начало загрузки автолифта до STD (SMS)\n  LOAD_DMS: 240,                // для DMS\n  WINDOW_TO_SERVICE: 15,        // от окна до начала обслуживания\n  SERVICE_SMS: 19,              // длительность обслуживания SMS\n  SERVICE_DMS: 45,              // длительность обслуживания DMS\n  LEAVE_BEFORE_STD: 60,         // отъезд от ВС до STD\n  RETURN_UNLOAD: 20,            // возврат в окно после обслуживания (20 мин)\n  TRAVEL: 20,                   // переезд между бортами\n\n  // визуал «скобки»\n  BRACKET_PAD_LEFT: 120,        // −2:00 от первого бара в цепочке\n  BRACKET_PAD_RIGHT: 0,         // без дополнительного хвоста — скобка заканчивается по разгрузке\n\n  // подсказка-буфер при dnd\n  RED_ZONE: 15,                 // 15 минут\n} as const;\n\n// Утилиты\nexport const uid = () => Math.random().toString(36).slice(2, 9);\nexport const clamp = (v: number, a: number, b: number) => Math.max(a, Math.min(b, v));\nexport const clampDay = (m: number) => clamp(m, DAY_START, DAY_END);\n\n// Функция для определения дня относительно базового дня (0 = текущий день)\nexport const getDayOffset = (m: number): number => {\n  if (m < 0) return -1; // Предыдущий день\n  if (m >= 24 * 60) return 1; // Следующий день\n  return 0; // Текущий день\n};\n\nexport function toHHMM(m: number): string {\n  // Нормализуем время с учетом расширенного диапазона\n  const totalMinutes = Math.round(m);\n  const hours = Math.floor(totalMinutes / 60);\n  const minutes = ((totalMinutes % 60) + 60) % 60;\n  \n  // Определяем дату относительно текущего дня\n  if (hours < 0) {\n    // Предыдущий день\n    const actualHours = ((hours % 24) + 24) % 24;\n    return `${actualHours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}`;\n  } else if (hours >= 24) {\n    // Следующий день\n    const actualHours = hours % 24;\n    return `${actualHours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}`;\n  } else {\n    // Текущий день\n    return `${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}`;\n  }\n}\n\n// Функция для компактного отображения времени с учетом дат\nexport function toCompactTime(start: number, end: number, width: number): string {\n  const startDay = getDayOffset(start);\n  const endDay = getDayOffset(end);\n  \n  if (width >= 90) {\n    // Полное время с пробелами для широких баров\n    return `${toHHMM(start)} - ${toHHMM(end)}`;\n  } else if (width >= 65) {\n    // Без пробелов для средних баров\n    return `${toHHMM(start)}-${toHHMM(end)}`;\n  } else if (width >= 50) {\n    // Сокращенное время без ведущих нулей\n    let shortStart = toHHMM(start).replace(/^0/, '');\n    let shortEnd = toHHMM(end).replace(/^0/, '');\n    return `${shortStart}-${shortEnd}`;\n  } else {\n    // Только время начала для очень узких баров\n    return toHHMM(start).replace(/^0/, '');\n  }\n}\n\nexport function toMin(hhmm: string): number {\n  const match = hhmm.match(/(\\d{1,2}):(\\d{2})/);\n  if (!match) return NaN;\n  return +match[1]*60 + +match[2];\n}\n\nexport const DMS_TYPES = new Set(['77W','77R','773','744','333','359']);\nexport const SMS_TYPES = new Set(['320','321','32A','32B','32N','32Q','73H','739','SU9']);\nexport const isDMS = (t: string) => DMS_TYPES.has(t.toUpperCase());\nexport const isSMS = (t: string) => SMS_TYPES.has(t.toUpperCase());\nexport const normType = (t: string) => t.toUpperCase().trim();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}